import os
import ConfigParser
from cStringIO import StringIO
from mercurial import ui, hg, revlog, demandimport, cmdutil, archival

# modified hgweb
from hgweb_ext import hgweb_ext as hgweb

# Mercurial exceptions to catch
from mercurial.hg import RepoError
from mercurial.util import Abort

demandimport.disable()

__all__ = [
    'Storage',
    'Sandbox',
]

class _ui(ui.ui):
    """\
    Monkey patching ui so output is proprogated to the parent's buffer.

    intended side effect is all output (wanted or not) from the spawned
    repo objs will have its output dumped into main ui object's buffer.

    unwanted side effects is unknown, but it appears this buffer is for
    storing the output generated by mercurial only for some other piece
    of code, so this overloaded/patched usage here is probably apt.
    """

    # XXX naturally remove this if I can find where the desired result
    # is supported by mercurial
    def __init__(self, parentui=None, *a, **kw):
        oldui.__init__(self, parentui, *a, **kw)
        if parentui:
            self.buffers = parentui.buffers

    write_err = ui.ui.write

oldui = ui.ui
ui.ui = _ui


def _t(name, **kw):
    kw[''] = name
    return kw


class Storage(object):
    """\ 
    Encapsulates a mercurial repository object.

    Provides methods to access and manipulate a mercurial repository.
    Based on mercurial.commands, but abstracted in a way that becomes a
    friendly software library that can be reused.

    This is a read only storage that borrows a lot of functionality from
    hgweb_mod.
    """

    def __init__(self, path, ctx=None):
        """\
        Creates the object wrapper for the repository object.

        This method only sets the repository path.

        `path' should be 'str', but 'unicode' is accepted but it will
        be encoded into a utf-8 encoded 'str' by default.
        """

        if isinstance(path, str):
            self._path = path
        elif isinstance(path, unicode):
            self._path = path.encode('utf8')
        else:
            raise TypeError('path must be an instance of basestring')
        
        self._ui = ui.ui(interactive=False)
        self._ui.pushbuffer()
        self._ui.readconfig(os.path.join(self._path, '.hg', 'hgrc'))
        try:
            self._repo = hg.repository(self._ui, self._path)
            self._hgweb = hgweb(self._repo)
            self._hgweb.t = _t
        except RepoError:
            # Repository initializing error.
            raise ValueError('repository does not exist at path')

        self._changectx(ctx)

    @staticmethod
    def create(path, create_dir=True):
        """\
        Creates a repository at the location that was specified during
        the creation of this repository object.

        `create_dir' specifies whether to create the directory for the
        hg repo if create is set to true.  Default: True
        """

        if create_dir:
            if os.path.isdir(path):
                raise ValueError('directory already exist; cannot create a '
                                 'new repository in existing directory')
            try:
                os.mkdir(path)
            except OSError:
                raise ValueError('repository directory cannot be created')

        result = False
        try:
            u = ui.ui(interactive=False)
            if hg.repository(u, path, create=1):
                result = True
        except:
            pass

        if not result:
            # XXX maybe IO error instead?
            raise ValueError("couldn't create repository at path")
        return result

    def _changectx(self, changeid=None):
        """\
        Much like changectx of mercurial repository, except it will
        pick the "default" branch as according to dirlist.

        This might be a private method as not all backend may require
        this once this class is migrated to using a standard interface.
        """

        if changeid is None:
            changeid = self._repo.dirstate.branch()

        try:
            self._ctx = self._repo.changectx(changeid)
        except RepoError:
            self._ctx = None

        return self._ctx

    def manifest(self, label=None, path=''):
        """\
        Returns a manifest of the current directory.
        """
        #Implemented as a wrapper around hgweb.manifest().

        if label is None:
            label = self._repo.dirstate.branch()
        ctx = self._changectx(label)
        if ctx is not None:
            return self._hgweb.manifest(ctx, path)
        else:
            raise ValueError('%s not found.' % label)

    @property
    def output(self):
        """\
        Returns raw outout generated by the backend.
        """
        result = self._ui.popbuffer()
        # reset the status messages.
        self._ui.pushbuffer()
        return result


class Sandbox(Storage):
    """\
    This class implements features that is required by the PMR2 sandbox
    upload model.  Features provided allows manipulation of files,
    creation of changesets (commits).
    """

    def __init__(self, *a, **kw):
        Storage.__init__(self, *a, **kw)
        #self.t = _t
        #self.stripecount = 1
        #self.hgweb.status = _status

    def _fullpath(self, name):
        """\
        validates and returns the name provided is within the context
        of this repository.

        all methods that need to create file need to call this first
        on the input name.
        """
        fn = os.path.normpath(os.path.join(self._path, name))
        if not fn.startswith(self._path):
            raise ValueError('supplied filename is outside repository')
        return fn

    def add(self, names):
        """\
        Selects a list of files to be added.

        Maybe break this one out?
        """
        fn = names
        if not isinstance(names, list):
            fn = [names]
        self._repo.add(fn)

    def add_file_content(self, name, content):
        """\
        This method adds content to the filename.
        """
        fn = self._fullpath(name)
        dirname = os.path.dirname(fn)
        if not os.path.isdir(dirname):
            # create the directory
            self.mkdir(dirname)
        fp = open(fn, 'wb')
        fp.write(content)
        fp.close()
        if not name in self._repo.dirstate:
            self._repo.add([name])

    def commit(self, message, user):
        """\
        Commits the changes made, returns the id of the new commit.
        """

        if not message:
            raise ValueError('message cannot be empty')
        if not user:
            raise ValueError('user cannot be empty')
        result = self._repo.commit([], message, user, '')
        # remaining parmas: files, message, user, date, match function
        if result is not None:
            # update to the new context
            self._changectx(result)
        return result

    def mkdir(self, dirname):
        """\
        Creates a dir with dirname.  Currently provided as helper.

        Normally there isn't a need to call this, as Mercurial does not
        track directories.  Adding a file to a specific location should
        create the directory if it does not already exist.
        """

        def mkdir_p(d):
            # make parent dir as needed.
            p, n = os.path.split(d)
            if not os.path.isdir(p):
                mkdir_p(p)
            if not os.path.isdir(d):
                # FIXME trap this call for below?
                os.mkdir(d)
            
        fn = self._fullpath(dirname)
        # FIXME customize exception message to show which dir failed?
        try:
            mkdir_p(fn)
        except OSError:
            raise
        return True

    def status(self, path=''):
        """\
        Status reports the state of the sandbox, for files that may have
        been added, modified, deleted and the like.

        Only compare the first dirstate parent and working directory.

        Returns a dictionary of the list of files.
        """

        st = self._repo.status(list_ignored=True, list_clean=True)
        return self._hgweb.status(self._ctx, path, st)
