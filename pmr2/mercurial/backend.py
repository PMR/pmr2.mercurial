import os
import ConfigParser
from cStringIO import StringIO
from mercurial import ui, hg, revlog, demandimport, cmdutil, archival
from mercurial.i18n import _

# XXX exists in Mercurial 0.9.5
from mercurial.commands import docopy

# modified hgweb
from hgweb_ext import hgweb_ext as hgweb

# Mercurial exceptions to catch
from mercurial.hg import RepoError
from mercurial.util import Abort
from mercurial.lock import LockHeld

from pmr2.mercurial.exceptions import *

demandimport.disable()

__all__ = [
    'Storage',
    'Sandbox',
]


class _ui(ui.ui):
    """\
    Monkey patching ui so output is proprogated to the parent's buffer.

    intended side effect is all output (wanted or not) from the spawned
    repo objs will have its output dumped into main ui object's buffer.

    unwanted side effects is unknown, but it appears this buffer is for
    storing the output generated by mercurial only for some other piece
    of code, so this overloaded/patched usage here is probably apt.
    """

    # XXX naturally remove this if I can find where the desired result
    # is supported by mercurial
    def __init__(self, parentui=None, *a, **kw):
        oldui.__init__(self, parentui, *a, **kw)
        if parentui:
            self.buffers = parentui.buffers

    write_err = ui.ui.write

oldui = ui.ui
ui.ui = _ui


def _t(name, **kw):
    kw[''] = name
    return kw

def _hgweb(repo):
    hw = hgweb(repo)
    hw.t = _t
    return hw


class Storage(object):
    """\ 
    Encapsulates a mercurial repository object.

    Provides methods to access and manipulate a mercurial repository.
    Based on mercurial.commands, but abstracted in a way that becomes a
    friendly software library that can be reused.

    This is a read only storage that borrows a lot of functionality from
    hgweb_mod.
    """

    def __init__(self, path, ctx=None):
        """\
        Creates the object wrapper for the repository object.

        This method only sets the repository path.

        `path' should be 'str', but 'unicode' is accepted but it will
        be encoded into a utf-8 encoded 'str' by default.
        """

        if isinstance(path, str):
            self._path = path
        elif isinstance(path, unicode):
            self._path = path.encode('utf8')
        else:
            raise TypeError('path must be an instance of basestring')
        
        self._ui = ui.ui(interactive=False)
        self._ui.pushbuffer()
        self._ui.readconfig(os.path.join(self._path, '.hg', 'hgrc'))
        try:
            self._repo = hg.repository(self._ui, self._path)
        except RepoError:
            # Repository initializing error.
            # XXX should include original traceback
            raise PathInvalid('repository does not exist at path')

        self._changectx(ctx)

    @staticmethod
    def create(path, create_dir=True):
        """\
        Creates a repository at the location that was specified during
        the creation of this repository object.

        `create_dir' specifies whether to create the directory for the
        hg repo if create is set to true.  Default: True
        """

        if create_dir:
            if os.path.isdir(path):
                raise PathExists('directory already exist; '
                        'cannot create a new repository in existing directory')
            try:
                os.makedirs(path, mode=0700)
            except OSError:
                raise PathInvalid('repository directory cannot be created')

        result = False
        try:
            u = ui.ui(interactive=False)
            if hg.repository(u, path, create=1):
                result = True
        except:
            # XXX should include original traceback
            # XXX assuming to be invalid path
            raise PathInvalid("couldn't create repository at path")

        return result

    def _changectx(self, changeid=None):
        """\
        A private helper method that wraps around changectx of 
        mercurial repository; it will pick the "default" branch as 
        according to dirlist.
        """

        try:
            self._ctx = self._repo.changectx(changeid)
        except RepoError:
            self._ctx = None
            if changeid is None:
                self._ctx = self._repo.changectx('tip')
        return self._ctx

    def clone(self, dest, rev=None, update=True):
        """\
        Clones this repository to target destination `dest'.

        dest -
            the destination.
        rev -
            specifies specific revisions to clone.
        """

        if not isinstance(dest, basestring):
            raise TypeError('dest must be an instance of basestring')

        if isinstance(dest, unicode):
            dest = dest.encode('utf8')

        dest = os.path.normpath(dest)

        if os.path.exists(dest):
            raise PathExists('dest already exists')

        pdir = os.path.split(dest)[0]
        if not os.path.exists(pdir):
            # try to create parent dir.
            try:
                os.makedirs(pdir, mode=0700)
            except:
                raise PathInvalid(
                        'cannot create directory with specified path')

        if rev:
            try:
                rev = [self._repo.lookup(rev)]
            except:
                raise RevisionNotFound('revision %s not found' % rev)

        clone_result = hg.clone(self._ui, source=self._path, dest=dest, 
                rev=rev, update=update)
        repo, repo_clone = clone_result
        # since it did get reinitialized.
        self._repo = repo

    def log(self, rev=None, branch=None, limit=None):
        """\
        This method returns the history of the repository.

        rev -
            specifies which revision to start the history from.
        branch -
            specifies which branch to check the logs on.

        This method is implemented as a wrapper around hgweb.changelog(),
        so the value return is actually an iterator, and the structure
        will likely change when this class is migrated to a common
        interface.
        """

        hw = _hgweb(self._repo)
        if limit is None:
            limit = 10
        hw.maxchanges = limit

        ctx = self._changectx(rev)
        if ctx is None:
            raise RevisionNotFound('revision %s not found' % rev)
        return hw.changelog(ctx)

    def manifest(self, rev=None, path=''):
        """\
        Returns a manifest of the current directory.

        This method is implemented as a wrapper around hgweb.changelog(),
        so the value return is actually an iterator, and the structure
        will likely change when this class is migrated to a common
        interface.
        """

        hw = _hgweb(self._repo)

        ctx = self._changectx(rev)
        if ctx is None:
            raise RevisionNotFound('revision %s not found' % rev)
        return hw.manifest(ctx, path)

    @property
    def output(self):
        """\
        Returns raw outout generated by the backend.
        """
        result = self._ui.popbuffer()
        # reset the status messages.
        self._ui.pushbuffer()
        return result


class Sandbox(Storage):
    """\
    This class implements features that is required by the PMR2 sandbox
    upload model.  Features provided allows manipulation of files,
    creation of changesets (commits).
    """

    def __init__(self, *a, **kw):
        Storage.__init__(self, *a, **kw)
        #self.t = _t
        #self.stripecount = 1
        #self.hgweb.status = _status

    def _fullpath(self, name):
        """\
        validates and returns the name provided is within the context
        of this repository.

        all methods that need to create file need to call this first
        on the input name.
        """
        if os.path.isabs(name):
            fn = name
        else:
            fn = os.path.normpath(os.path.join(self._path, name))
        if not fn.startswith(self._path):
            raise PathInvalid('supplied path is outside repository')
        return fn

    def _filter_paths(self, paths):
        # filter out paths using fullpath.
        # assumes files in manifest/status exist on filesystem

        def fullpath(name):
            try: return self._fullpath(name)
            except: return None

        # must resolve full path as cwd is almost always elsewhere.
        result = [fullpath(i) for i in paths]
        result = [i for i in result if i is not None and os.path.exists(i)]
        return result

    def _source_check(self, source):
        # param type check
        if isinstance(source, basestring):
            # XXX can this really work with unicode?  below also
            return [source]
        if not isinstance(source, list):
            raise TypeError(
                    'source must be either a list of strings or a string')
        for i in source:
            if not isinstance(i, basestring):
                raise TypeError('invalid type present in source list')
        return source

    def add(self, names):
        """\
        Selects a list of files to be added.

        Maybe break this one out?
        """
        fn = names
        if not isinstance(names, list):
            fn = [names]
        self._repo.add(fn)

    def add_file_content(self, name, content):
        """\
        This method adds content to the filename.
        """
        fn = self._fullpath(name)
        dirname = os.path.dirname(fn)
        if not os.path.isdir(dirname):
            # create the directory
            self.mkdir(dirname)
        fp = open(fn, 'wb')
        fp.write(content)
        fp.close()
        if not name in self._repo.dirstate:
            self._repo.add([name])

    def commit(self, message, user):
        """\
        Commits the changes made, returns the id of the new commit.
        """

        if not message:
            raise ValueError('message cannot be empty')
        if not user:
            raise ValueError('user cannot be empty')
        result = self._repo.commit([], message, user, '')
        # remaining parmas: files, message, user, date, match function
        if result is not None:
            # we have new context
            self._changectx(result)
        return result

    def mkdir(self, dirname):
        """\
        Creates a dir with dirname.  Currently provided as helper.

        Normally there isn't a need to call this, as Mercurial does not
        track directories.  Adding a file to a specific location should
        create the directory if it does not already exist.
        """

        fn = self._fullpath(dirname)
        if not os.path.exists(fn):
            try:
                os.makedirs(fn, mode=0700)
            except:  # OSError:
                raise PathInvalid(
                        'cannot create directory with specified path')
        elif not os.path.isdir(fn):
            raise PathExists('cannot create directory; '
                                    'path already exists')
        return True

    def pull(self, source='default', update=True):
        """\
        Pull new revisions from source.

        source -
            if value is 'default', the default source of this repo will 
            be used.

            Default: 'default'
        update -
            if True, this sandbox will be updated to the latest data
            that was pulled, if possible.

        return value is a number of total heads generated from the pull.

        0 = no changes
        1 = updated
        >1 = merge will be required, no automatic update
        """

        # not using another Storage because localrepo.addchangegroup
        # appends output to its ui, so the 'other' repo must be
        # created using the ui belonging to this object.
        if not isinstance(source, basestring):
            raise TypeError('source must be a string')
            # pull from main repo only.
        # XXX could implement pull up to specific revs
        source, revs, checkout = hg.parseurl(source, [])
        if source == 'default':
            raise RepoNotFound('no suitable repository found')

        other = hg.repository(self._ui, source)
        self._ui.status('pulling from %s\n' % (source))
        modheads = self._repo.pull(other, revs)

        if update:
            if modheads <= 1 or checkout:
                hg.update(self._repo, checkout)
                self._changectx()
            else:
                self._ui.status(_("not updating, since new heads added\n"))

        return modheads

    def push(self, dest=None, rev=None, force=False):
        """\
        Push changes into destination.

        If destination is none, the source of this repo will be used.

        If revision is not specified, the current working dir will be
        pushed.  If this spawns a new head, this operation must be
        forced.

        Forcing will have the side effect of creating a new branch, and
        it may not be desirable.

        By default, no remote branch will be created.
        """

        # find parents
        # if there are two parents, take the first one,
        #   (ui should warn users about uncommitted merge/confirmation)
        # if not force, do it and see if head shows up

        if rev is None:
            rev = [self._repo.lookup('.')]

        dest, revs, checkout = hg.parseurl(
            self._ui.expandpath(dest or 'default-push', 
                                dest or 'default'), rev)

        if dest in ('default', 'default-push',):
            raise RepoNotFound('no suitable target found')
        other = hg.repository(self._ui, dest)
        self._ui.status('pushing to %s\n' % (dest))
        if revs:
            revs = [self._repo.lookup(rev) for rev in revs]
        r = self._repo.push(other, force, revs=revs)
        # check to see if this revision is present on destination
        # XXX assuming other is localrepo
        try:
            result = other.lookup(revs[0])
        except:
            result = None
        return result is not None

    def remove(self, source):
        """\
        This method removes files.

        source -
            the list of files to remove.  string or list of strings.
        """

        filtered = self._source_check(source)
        filtered = self._filter_paths(filtered)

        remove = []
        for src, abs, rel, exact in cmdutil.walk(self._repo, filtered, {}):
            remove.append(self._fullpath(abs))

        forget = []
        # using status, which is relative path within the repo
        added = self._repo.status()[1]
        for i in source:
            if i in added:
                forget.append(i)
        self._repo.forget(forget)
        self._repo.remove(remove, unlink=True)

    def rename(self, source, dest):
        """\
        This method contains a copy of mercurial.commands.rename, used
        to rename source into dest.

        source -
            either a string of a list of strings
        dest -
            must be a string.
        with the option 'force' enabled.

        Return values are the number of errors, and a list of files
        that have been copied if the call was successful.
        """
        # FIXME exceptions here will need to be specified for the 
        # generic interface when migrated.
        # FIXME should use Mercurial 1.0.2 (1.0.0?) because the copy
        # function provided will allow copy + remove for rename.  So
        # there will be no need to implement copy separately here.

        # param type check
        source = self._source_check(source)
        if not isinstance(dest, basestring):
            # XXX can this really work with unicode?  below also
            raise TypeError('dest must be of type string')

        # source validation + param type check
        pats = self._filter_paths(source)
        if not pats:
            raise ValueError('no valid source found')

        # destination.
        f_dest = self._fullpath(dest)

        c = len(pats)
        if c == 0:
            # no safe files, length of source = # of errors.
            return len(source), []
        if c == 1:
            if os.path.exists(f_dest) and not os.path.isdir(f_dest):
                raise PathNotDir(
                        'destination exists and is not a directory')
                # in UI, it could prompt the user that the dest file 
                # will be overwritten, and implement it as delete of 
                # dest and move from source to dest.
        else:
            # make path if source files > 1 as required by docopy
            self.mkdir(f_dest)

        perrs = len(source) - c  # number of invalid source
        pats.append(f_dest)  # add destination for Mercurial's docopy.

        # docopy required options.
        opts = {'force': 1, 'after': 0}

        def rename(ui, repo):
            # copied from mercurial.commands.rename (0.9.5)
            # slightly modified, see below
            wlock = repo.wlock(False)
            try:
                errs, copied = docopy(ui, repo, pats, opts)
                names = []
                for abs, rel, exact in copied:
                    if ui.verbose or not exact:
                        ui.status(_('removing %s\n') % rel)
                    names.append(abs)
                if not opts.get('dry_run'):
                    repo.remove(names, True)
                return errs, copied  # also return copied
            finally:
                del wlock

        # XXX this can raise hg specific exceptions!
        # FIXME for the standardized library, common exception
        # classes independent from specific libraries must be used.
        errs, copied = rename(self._ui, self._repo)
        errs += perrs
        return errs, copied

    def status(self, path=''):
        """\
        Status reports the state of the sandbox, for files that may have
        been added, modified, deleted and the like.

        Only compare the first dirstate parent and working directory.

        Returns a dictionary of the list of files.
        """

        # get back to latest working copy because this is what we want.
        ctx = self._changectx()
        st = self._repo.status(list_ignored=True, list_clean=True)

        hw = _hgweb(self._repo)
        return hw.status(self._ctx, path, st)
