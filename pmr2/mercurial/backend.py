import os
import ConfigParser
from cStringIO import StringIO
from mercurial import ui, hg, revlog, demandimport, cmdutil, archival

# XXX exists in Mercurial 0.9.5
from mercurial.commands import docopy

# modified hgweb
from hgweb_ext import hgweb_ext as hgweb

# Mercurial exceptions to catch
from mercurial.hg import RepoError
from mercurial.util import Abort
from mercurial.lock import LockHeld

demandimport.disable()

__all__ = [
    'Storage',
    'Sandbox',
]

class _ui(ui.ui):
    """\
    Monkey patching ui so output is proprogated to the parent's buffer.

    intended side effect is all output (wanted or not) from the spawned
    repo objs will have its output dumped into main ui object's buffer.

    unwanted side effects is unknown, but it appears this buffer is for
    storing the output generated by mercurial only for some other piece
    of code, so this overloaded/patched usage here is probably apt.
    """

    # XXX naturally remove this if I can find where the desired result
    # is supported by mercurial
    def __init__(self, parentui=None, *a, **kw):
        oldui.__init__(self, parentui, *a, **kw)
        if parentui:
            self.buffers = parentui.buffers

    write_err = ui.ui.write

oldui = ui.ui
ui.ui = _ui


def _t(name, **kw):
    kw[''] = name
    return kw


class Storage(object):
    """\ 
    Encapsulates a mercurial repository object.

    Provides methods to access and manipulate a mercurial repository.
    Based on mercurial.commands, but abstracted in a way that becomes a
    friendly software library that can be reused.

    This is a read only storage that borrows a lot of functionality from
    hgweb_mod.
    """

    def __init__(self, path, ctx=None):
        """\
        Creates the object wrapper for the repository object.

        This method only sets the repository path.

        `path' should be 'str', but 'unicode' is accepted but it will
        be encoded into a utf-8 encoded 'str' by default.
        """

        if isinstance(path, str):
            self._path = path
        elif isinstance(path, unicode):
            self._path = path.encode('utf8')
        else:
            raise TypeError('path must be an instance of basestring')
        
        self._ui = ui.ui(interactive=False)
        self._ui.pushbuffer()
        self._ui.readconfig(os.path.join(self._path, '.hg', 'hgrc'))
        try:
            self._repo = hg.repository(self._ui, self._path)
            self._hgweb = hgweb(self._repo)
            self._hgweb.t = _t
        except RepoError:
            # Repository initializing error.
            # XXX should include original traceback
            raise ValueError('repository does not exist at path')

        self._changectx(ctx)

    @staticmethod
    def create(path, create_dir=True):
        """\
        Creates a repository at the location that was specified during
        the creation of this repository object.

        `create_dir' specifies whether to create the directory for the
        hg repo if create is set to true.  Default: True
        """

        if create_dir:
            if os.path.isdir(path):
                raise ValueError('directory already exist; cannot create a '
                                 'new repository in existing directory')
            try:
                os.mkdir(path)
            except OSError:
                raise ValueError('repository directory cannot be created')

        result = False
        try:
            u = ui.ui(interactive=False)
            if hg.repository(u, path, create=1):
                result = True
        except:
            # XXX should include original traceback
            raise ValueError("couldn't create repository at path")

        return result

    def _changectx(self, changeid=None):
        """\
        Much like changectx of mercurial repository, except it will
        pick the "default" branch as according to dirlist.

        This might be a private method as not all backend may require
        this once this class is migrated to using a standard interface.
        """

        if changeid is None:
            changeid = self._repo.dirstate.branch()

        try:
            self._ctx = self._repo.changectx(changeid)
        except RepoError:
            self._ctx = None

        return self._ctx

    def manifest(self, label=None, path=''):
        """\
        Returns a manifest of the current directory.
        """
        #Implemented as a wrapper around hgweb.manifest().

        if label is None:
            label = self._repo.dirstate.branch()
        ctx = self._changectx(label)
        if ctx is not None:
            return self._hgweb.manifest(ctx, path)
        else:
            raise ValueError('%s not found.' % label)

    @property
    def output(self):
        """\
        Returns raw outout generated by the backend.
        """
        result = self._ui.popbuffer()
        # reset the status messages.
        self._ui.pushbuffer()
        return result


class Sandbox(Storage):
    """\
    This class implements features that is required by the PMR2 sandbox
    upload model.  Features provided allows manipulation of files,
    creation of changesets (commits).
    """

    def __init__(self, *a, **kw):
        Storage.__init__(self, *a, **kw)
        #self.t = _t
        #self.stripecount = 1
        #self.hgweb.status = _status

    def _fullpath(self, name):
        """\
        validates and returns the name provided is within the context
        of this repository.

        all methods that need to create file need to call this first
        on the input name.
        """
        if os.path.isabs(name):
            fn = name
        else:
            fn = os.path.normpath(os.path.join(self._path, name))
        if not fn.startswith(self._path):
            raise ValueError('supplied filename is outside repository')
        return fn

    def _filter_paths(self, paths):
        # filter out paths using fullpath.
        # assumes files in manifest/status exist on filesystem

        def fullpath(name):
            try: return self._fullpath(name)
            except: return None

        # must resolve full path as cwd is almost always elsewhere.
        result = [fullpath(i) for i in paths]
        result = [i for i in result if i is not None and os.path.exists(i)]
        return result

    def _source_check(self, source):
        # param type check
        if isinstance(source, basestring):
            # XXX can this really work with unicode?  below also
            return [source]
        if not isinstance(source, list):
            raise TypeError(
                    'source must be either a list of strings or a string')
        for i in source:
            if not isinstance(i, basestring):
                raise TypeError('invalid type present in source list')
        return source

    def add(self, names):
        """\
        Selects a list of files to be added.

        Maybe break this one out?
        """
        fn = names
        if not isinstance(names, list):
            fn = [names]
        self._repo.add(fn)

    def add_file_content(self, name, content):
        """\
        This method adds content to the filename.
        """
        fn = self._fullpath(name)
        dirname = os.path.dirname(fn)
        if not os.path.isdir(dirname):
            # create the directory
            self.mkdir(dirname)
        fp = open(fn, 'wb')
        fp.write(content)
        fp.close()
        if not name in self._repo.dirstate:
            self._repo.add([name])

    def commit(self, message, user):
        """\
        Commits the changes made, returns the id of the new commit.
        """

        if not message:
            raise ValueError('message cannot be empty')
        if not user:
            raise ValueError('user cannot be empty')
        result = self._repo.commit([], message, user, '')
        # remaining parmas: files, message, user, date, match function
        if result is not None:
            # update to the new context
            self._changectx(result)
        return result

    def mkdir(self, dirname):
        """\
        Creates a dir with dirname.  Currently provided as helper.

        Normally there isn't a need to call this, as Mercurial does not
        track directories.  Adding a file to a specific location should
        create the directory if it does not already exist.
        """

        fn = self._fullpath(dirname)
        if not os.path.exists(fn):
            try:
                os.makedirs(fn, mode=0700)
            except:  # OSError:
                raise ValueError('cannot create directory with specified path')
        elif not os.path.isdir(fn):
            raise ValueError('cannot create directory; path already exists')
        return True

    def remove(self, source):
        """\
        This method removes files.

        source -
            the list of files to remove.  string or list of strings.
        """

        filtered = self._source_check(source)
        filtered = self._filter_paths(filtered)

        remove = []
        for src, abs, rel, exact in cmdutil.walk(self._repo, filtered, {}):
            remove.append(self._fullpath(abs))

        forget = []
        # using status, which is relative path within the repo
        added = self._repo.status()[1]
        for i in source:
            if i in added:
                forget.append(i)
        self._repo.forget(forget)
        self._repo.remove(remove, unlink=True)

    def rename(self, source, dest):
        """\
        This method contains a copy of mercurial.commands.rename, used
        to rename source into dest.

        source -
            either a string of a list of strings
        dest -
            must be a string.
        with the option 'force' enabled.

        Return values are the number of errors, and a list of files
        that have been copied if the call was successful.
        """
        # FIXME exceptions here will need to be specified for the 
        # generic interface when migrated.

        # param type check
        source = self._source_check(source)
        if not isinstance(dest, basestring):
            # XXX can this really work with unicode?  below also
            raise TypeError('dest must be of type string')

        # source validation + param type check
        pats = self._filter_paths(source)
        if not pats:
            raise ValueError('no valid source found')

        # destination.
        try: f_dest = self._fullpath(dest)
        except ValueError:
            raise ValueError('destination path is outside the repository')

        c = len(pats)
        if c == 0:
            # no safe files, length of source = # of errors.
            return len(source), []
        if c == 1:
            if os.path.exists(f_dest) and not os.path.isdir(f_dest):
                raise ValueError('destination exists and is not a directory')
        else:
            # make path if source files > 1 as required by docopy
            self.mkdir(f_dest)

        perrs = len(source) - c  # number of invalid source
        pats.append(f_dest)  # add destination for Mercurial's docopy.

        # docopy required options.
        opts = {'force': 1, 'after': 0}

        def rename(ui, repo):
            # copied from mercurial.commands.rename (0.9.5)
            # slightly modified, see below
            wlock = repo.wlock(False)
            try:
                errs, copied = docopy(ui, repo, pats, opts)
                names = []
                for abs, rel, exact in copied:
                    if ui.verbose or not exact:
                        ui.status('removing %s\n' % rel)  # removed _
                    names.append(abs)
                if not opts.get('dry_run'):
                    repo.remove(names, True)
                return errs, copied  # also return copied
            finally:
                del wlock

        # XXX this can raise hg specific exceptions!
        # FIXME for the standardized library, common exception
        # classes independent from specific libraries must be used.
        errs, copied = rename(self._ui, self._repo)
        errs += perrs
        return errs, copied

    def status(self, path=''):
        """\
        Status reports the state of the sandbox, for files that may have
        been added, modified, deleted and the like.

        Only compare the first dirstate parent and working directory.

        Returns a dictionary of the list of files.
        """

        st = self._repo.status(list_ignored=True, list_clean=True)
        return self._hgweb.status(self._ctx, path, st)
