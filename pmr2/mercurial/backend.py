import os
import ConfigParser
from cStringIO import StringIO
from mercurial import ui, hg, revlog, demandimport, cmdutil, archival
from mercurial.i18n import _

# XXX exists in Mercurial 0.9.5
try:
    from mercurial.commands import docopy
except:
    pass

# modified hgweb
from hgweb_ext import hgweb_ext as hgweb

# Mercurial exceptions to catch
from mercurial.repo import RepoError
from mercurial.util import Abort
from mercurial.lock import LockHeld
from mercurial.hgweb.common import ErrorResponse

from pmr2.mercurial.exceptions import *

demandimport.disable()

__all__ = [
    'Storage',
    'Sandbox',
]


class _ui(ui.ui):
    """\
    Monkey patching ui so output is proprogated to the parent's buffer.

    intended side effect is all output (wanted or not) from the spawned
    repo objs will have its output dumped into main ui object's buffer.

    unwanted side effects is unknown, but it appears this buffer is for
    storing the output generated by mercurial only for some other piece
    of code, so this overloaded/patched usage here is probably apt.
    """

    # XXX naturally remove this if I can find where the desired result
    # is supported by mercurial
    def __init__(self, parentui=None, *a, **kw):
        oldui.__init__(self, parentui, *a, **kw)
        if parentui:
            self.buffers = parentui.buffers

    write_err = ui.ui.write

oldui = ui.ui
ui.ui = _ui

class _cwd:
    """ placeholder value for current working dir """


def _t(name, **kw):
    kw[''] = name
    yield kw


class Storage(object):
    """\ 
    Encapsulates a mercurial repository object.

    Provides methods to access and manipulate a mercurial repository.
    Based on mercurial.commands, but abstracted in a way that becomes a
    friendly software library that can be reused.

    This is a read only storage that borrows a lot of functionality from
    hgweb_mod.
    """

    def __init__(self, path, ctx=None):
        """\
        Creates the object wrapper for the repository object.

        This method only sets the repository path.

        `path' should be 'str', but 'unicode' is accepted but it will
        be encoded into a utf-8 encoded 'str' by default.
        """

        if isinstance(path, str):
            self._path = path
        elif isinstance(path, unicode):
            self._path = path.encode('utf8')
        else:
            raise TypeError('path must be an instance of basestring')
        
        self._ui = ui.ui(interactive=False)
        self._ui.pushbuffer()
        self._ui.readconfig(os.path.join(self._path, '.hg', 'hgrc'))
        try:
            self._repo = hg.repository(self._ui, self._path)
        except RepoError:
            # Repository initializing error.
            # XXX should include original traceback
            raise PathInvalid('repository does not exist at path')

        self._changectx(ctx)

    @staticmethod
    def create(path, create_dir=True):
        """\
        Creates a repository at the location that was specified during
        the creation of this repository object.

        `create_dir' specifies whether to create the directory for the
        hg repo if create is set to true.  Default: True
        """

        if create_dir:
            if os.path.isdir(path):
                raise PathExists('directory already exist; '
                        'cannot create a new repository in existing directory')
            try:
                os.makedirs(path, mode=0700)
            except OSError:
                raise PathInvalid('repository directory cannot be created')

        result = False
        try:
            u = ui.ui(interactive=False)
            if hg.repository(u, path, create=1):
                result = True
        except:
            # XXX should include original traceback
            # XXX assuming to be invalid path
            raise PathInvalid("couldn't create repository at path")

        return result

    def _changectx(self, changeid=None):
        """\
        A private helper method that wraps around changectx of 
        mercurial repository; it will pick the "default" branch as 
        according to dirlist.
        """

        try:
            self._ctx = self._repo.changectx(changeid)
        except RepoError:
            #self._ctx = None
            if changeid is None:
                self._ctx = self._repo.changectx('tip')
            else:
                raise RevisionNotFound('revision %s not found' % changeid)
        return self._ctx

    def branches(self):
        return self._repo.branchtags()

    def clone(self, dest, rev=None, update=True):
        """\
        Clones this repository to target destination `dest'.

        dest -
            the destination.
        rev -
            specifies specific revisions to clone.
        """

        if not isinstance(dest, basestring):
            raise TypeError('dest must be an instance of basestring')

        if isinstance(dest, unicode):
            dest = dest.encode('utf8')

        dest = os.path.normpath(dest)

        if os.path.exists(dest):
            raise PathExists('dest already exists')

        pdir = os.path.split(dest)[0]
        if not os.path.exists(pdir):
            # try to create parent dir.
            try:
                os.makedirs(pdir, mode=0700)
            except:
                raise PathInvalid(
                        'cannot create directory with specified path')

        if rev:
            try:
                rev = [self._repo.lookup(rev)]
            except:
                raise RevisionNotFound('revision %s not found' % rev)

        clone_result = hg.clone(self._ui, source=self._path, dest=dest, 
                rev=rev, update=update)
        repo, repo_clone = clone_result
        # since it did get reinitialized.
        self._repo = repo

    def log(self, rev=None, branch=None, limit=None):
        """\
        This method returns the history of the repository.

        rev -
            specifies which revision to start the history from.
        branch -
            specifies which branch to check the logs on.

        This method is implemented as a wrapper around hgweb.changelog(),
        so the value return is actually an iterator, and the structure
        will likely change when this class is migrated to a common
        interface.
        """

        hw = hgweb(self._repo)
        if limit is None:
            limit = 10
        hw.maxchanges = limit

        ctx = self._changectx(rev)
        return hw.changelog(_t, ctx)

    def manifest(self, rev=None, path=''):
        """\
        Returns a manifest of the current directory.

        This method is implemented as a wrapper around hgweb.changelog(),
        so the value return is actually an iterator, and the structure
        will likely change when this class is migrated to a common
        interface.

        As per hgweb manifest, if there file listing is empty, exception
        is raised - this includes a newly instantiated repository.  Use
        Sandbox, and call the status method instead to get the contents.
        """

        hw = hgweb(self._repo)

        ctx = self._changectx(rev)
        try:
            return hw.manifest(_t, ctx, path)
        except ErrorResponse:
            # as we do have a valid context, and if path is empty...
            if not path:
                raise RepoEmpty('repository is empty')
            else:
                raise PathNotFound("path '%s' not found" % path)

    def _filectx(self, rev=None, path=None):
        """\
        Returns contents of file.
        """
        if not path:
            raise PathNotFound('path not found')

        ctx = self._changectx(rev)
        try:
            return ctx.filectx(path)
        except revlog.LookupError:
            raise PathNotFound("path '%s' not found" % path)

    def file(self, rev=None, path=None):
        fctx = self._filectx(rev, path)
        return fctx.data()

    def fileinfo(self, rev=None, path=None):
        hw = hgweb(self._repo)
        fctx = self._filectx(rev, path)
        return hw.filerevision(_t, fctx)

    def tags(self):
        return self._repo.tags()

    @property
    def output(self):
        """\
        Returns raw outout generated by the backend.
        """
        result = self._ui.popbuffer()
        # reset the status messages.
        self._ui.pushbuffer()
        return result


class Sandbox(Storage):
    """\
    This class implements features that is required by the PMR2 sandbox
    upload model.  Features provided allows manipulation of files,
    creation of changesets (commits).
    """

    def __init__(self, *a, **kw):
        Storage.__init__(self, *a, **kw)
        #self.t = _t
        #self.stripecount = 1
        #self.hgweb.status = _status

    def _changectx(self, changeid=None):
        """\
        Returns working context by default
        """
        # XXX attribute selection could use some work.

        if changeid is _cwd:
            self._ctx = self._repo.workingctx()
            return self._ctx
        else:
            return Storage._changectx(self, changeid)

    def _fullpath(self, name):
        """\
        validates and returns the name provided is within the context
        of this repository.

        all methods that need to create file need to call this first
        on the input name.
        """
        if os.path.isabs(name):
            fn = name
        else:
            fn = os.path.normpath(os.path.join(self._path, name))
        if not fn.startswith(self._path):
            raise PathInvalid('supplied path is outside repository')
        return fn

    def _filter_paths(self, paths):
        # filter out paths using fullpath.
        # assumes files in manifest/status exist on filesystem

        def fullpath(name):
            try: return self._fullpath(name)
            except: return None

        # must resolve full path as cwd is almost always elsewhere.
        result = [fullpath(i) for i in paths]
        result = [i for i in result if i is not None and os.path.exists(i)]
        return result

    def _source_check(self, source):
        # param type check
        if isinstance(source, basestring):
            # XXX can this really work with unicode?  below also
            return [source]
        if not isinstance(source, list):
            raise TypeError(
                    'source must be either a list of strings or a string')
        for i in source:
            if not isinstance(i, basestring):
                raise TypeError('invalid type present in source list')
        return source

    def add(self, names):
        """\
        Selects a list of files to be added.

        Maybe break this one out?
        """
        fn = names
        if not isinstance(names, list):
            fn = [names]
        self._repo.add(fn)

    def add_file_content(self, name, content):
        """\
        This method adds content to the filename.
        """
        fn = self._fullpath(name)
        dirname = os.path.dirname(fn)
        if not os.path.isdir(dirname):
            # create the directory
            self.mkdir(dirname)
        fp = open(fn, 'wb')
        fp.write(content)
        fp.close()
        if not name in self._repo.dirstate:
            self._repo.add([name])

    def commit(self, message, user):
        """\
        Commits the changes made, returns the id of the new commit.
        """

        if not message:
            raise ValueError('message cannot be empty')
        if not user:
            raise ValueError('user cannot be empty')
        result = self._repo.commit([], message, user, '')
        # remaining parmas: files, message, user, date, match function
        if result is not None:
            # we have new context
            self._changectx(result)
        return result

    def current_branch(self):
        return self._repo.dirstate.branch()

    def file(self, rev=_cwd, path=None):
        """
        Get the file in working directory using the working directory
        context.
        """

        fctx = self._filectx(rev, path)
        return fctx.data()

    def fileinfo(self, rev=_cwd, path=None):
        """
        Get the fileinfo in working directory using the working 
        directory context.
        """

        fctx = self._filectx(rev, path)
        if rev is _cwd and path not in fctx.manifest():
            raise PathNotFound("path '%s' not found" % path)
        hw = hgweb(self._repo)
        return hw.filerevision(_t, fctx)

    def mkdir(self, dirname):
        """\
        Creates a dir with dirname.  Currently provided as helper.

        Normally there isn't a need to call this, as Mercurial does not
        track directories.  Adding a file to a specific location should
        create the directory if it does not already exist.
        """

        fn = self._fullpath(dirname)
        if not os.path.exists(fn):
            try:
                os.makedirs(fn, mode=0700)
            except:  # OSError:
                raise PathInvalid(
                        'cannot create directory with specified path')
        elif not os.path.isdir(fn):
            raise PathExists('cannot create directory; '
                                    'path already exists')
        return True

    def pull(self, source='default', update=True):
        """\
        Pull new revisions from source.

        source -
            if value is 'default', the default source of this repo will 
            be used.

            Default: 'default'
        update -
            if True, this sandbox will be updated to the latest data
            that was pulled, if possible.

        return value is a number of total heads generated from the pull.

        0 = no changes
        1 = updated
        >1 = merge will be required, no automatic update
        """

        # not using another Storage because localrepo.addchangegroup
        # appends output to its ui, so the 'other' repo must be
        # created using the ui belonging to this object.
        if not isinstance(source, basestring):
            raise TypeError('source must be a string')
            # pull from main repo only.
        # XXX could implement pull up to specific revs
        source, revs, checkout = hg.parseurl(source, [])
        if source == 'default':
            raise RepoNotFound('no suitable repository found')

        other = hg.repository(self._ui, source)
        self._ui.status('pulling from %s\n' % (source))
        modheads = self._repo.pull(other, revs)

        if update:
            if modheads <= 1 or checkout:
                hg.update(self._repo, checkout)
                self._changectx()
            else:
                self._ui.status(_("not updating, since new heads added\n"))

        return modheads

    def push(self, dest=None, rev=None, force=False):
        """\
        Push changes into destination.

        If destination is none, the source of this repo will be used.

        If revision is not specified, the current working dir will be
        pushed.  If this spawns a new head, this operation must be
        forced.

        Forcing will have the side effect of creating a new branch, and
        it may not be desirable.

        By default, no remote branch will be created.
        """

        # find parents
        # if there are two parents, take the first one,
        #   (ui should warn users about uncommitted merge/confirmation)
        # if not force, do it and see if head shows up

        if rev is None:
            rev = [self._repo.lookup('.')]

        dest, revs, checkout = hg.parseurl(
            self._ui.expandpath(dest or 'default-push', 
                                dest or 'default'), rev)

        if dest in ('default', 'default-push',):
            raise RepoNotFound('no suitable target found')
        other = hg.repository(self._ui, dest)
        self._ui.status('pushing to %s\n' % (dest))
        if revs:
            revs = [self._repo.lookup(rev) for rev in revs]
        r = self._repo.push(other, force, revs=revs)
        # check to see if this revision is present on destination
        # XXX assuming other is localrepo
        try:
            result = other.lookup(revs[0])
        except:
            result = None
        return result is not None

    def remove(self, source):
        """\
        This method removes files.

        source -
            the list of files to remove.  string or list of strings.
        """

        filtered = self._filter_paths(self._source_check(source))
        remove, forget = [], []
        for src, abs, rel, exact in cmdutil.walk(self._repo, filtered, {}):
            remove.append(abs)
        # using status, which is relative path within the repo
        added = self._filter_paths(self._repo.status()[1])
        for i in filtered:
            if i in added:
                forget.append(i)
        self._repo.forget(forget)
        self._repo.remove(remove, unlink=True)

    def rename(self, source, dest, force=False):
        """\
        This method contains a copy of mercurial.commands.rename, used
        to rename source into dest.

        source -
            either a string of a list of strings
        dest -
            must be a string.
        with the option 'force' enabled.

        Return values are the number of errors, and a list of files
        that have been copied if the call was successful.
        """
        # FIXME exceptions here will need to be specified for the 
        # generic interface when migrated.
        # FIXME should use Mercurial 1.0.2 (1.0.0?) because the copy
        # function provided will allow copy + remove for rename.  So
        # there will be no need to implement copy separately here.

        # param type check
        source = self._source_check(source)
        if not isinstance(dest, basestring):
            # XXX can this really work with unicode?  below also
            raise TypeError('dest must be of type string')

        # source validation + param type check
        pats = self._filter_paths(source)
        if not pats:
            raise ValueError('no valid source found')

        # destination.
        f_dest = self._fullpath(dest)

        c = len(pats)
        if c == 0:
            # no safe files, length of source = # of errors.
            return len(source), []
        if c == 1:
            if os.path.exists(f_dest) and not os.path.isdir(f_dest):
                raise PathNotDir(
                        'destination exists and is not a directory')
                # in UI, it could prompt the user that the dest file 
                # will be overwritten, and implement it as delete of 
                # dest and move from source to dest.
        else:
            # make path if source files > 1 as required by docopy
            self.mkdir(f_dest)

        perrs = len(source) - c  # number of invalid source
        pats.append(f_dest)  # add destination for Mercurial's docopy.

        # docopy required options.
        opts = {'force': 1, 'after': 0}

        def rename(ui, repo):
            # copied from mercurial.commands.rename (0.9.5)
            # slightly modified, see below
            wlock = repo.wlock(False)
            try:
                errs, copied = docopy(ui, repo, pats, opts)
                names = []
                for abs, rel, exact in copied:
                    if ui.verbose or not exact:
                        ui.status(_('removing %s\n') % rel)
                    names.append(abs)
                if not opts.get('dry_run'):
                    repo.remove(names, True)
                return errs, copied  # also return copied
            finally:
                del wlock

        # XXX this can raise hg specific exceptions!
        # FIXME for the standardized library, common exception
        # classes independent from specific libraries must be used.
        errs, copied = rename(self._ui, self._repo)
        errs += perrs
        return errs, copied

    def status(self, path=''):
        """\
        Status reports the state of the sandbox, for files that may have
        been added, modified, deleted and the like.

        Only compare the first dirstate parent and working directory.

        Returns a dictionary of the list of files.
        """

        # get back to latest working copy because this is what we want.
        ctx = self._changectx(_cwd)
        st = self._repo.status(list_ignored=True, list_clean=True)

        hw = hgweb(self._repo)
        return hw.status(_t, self._ctx, path, st)

# XXX features missing compared to prototype in pmr2.hgpmr.repository
# - archive: should be done via hgweb
# - tagging: should be done in sandbox (to create .hgtag)
# - merging: this must be done more comprehensively than prototype
# - forest snapshot: it was more a hack

# XXX modified commands.rename from mercurial 1.0.2
def hg_rename(ui, repo, *pats, **opts):
    wlock = repo.wlock(False)
    try:
        return hg_copy(ui, repo, pats, opts, rename=True)
    finally:
        del wlock

# XXX modified cmdutil.copy from mercurial 1.0.2
# changes to return a list of files moved.

def hg_copy(ui, repo, pats, opts, rename=False):
    # called with the repo lock held
    #
    # hgsep => pathname that uses "/" to separate directories
    # ossep => pathname that uses os.sep to separate directories
    cwd = repo.getcwd()
    targets = {}
    after = opts.get("after")
    dryrun = opts.get("dry_run")

    def walkpat(pat):
        srcs = []
        for tag, abs, rel, exact in cmdutil.walk(repo, [pat], opts, globbed=True):
            state = repo.dirstate[abs]
            if state in '?r':
                if exact and state == '?':
                    ui.warn(_('%s: not copying - file is not managed\n') % rel)
                if exact and state == 'r':
                    ui.warn(_('%s: not copying - file has been marked for'
                              ' remove\n') % rel)
                continue
            # abs: hgsep
            # rel: ossep
            srcs.append((abs, rel, exact))
        return srcs

    # abssrc: hgsep
    # relsrc: ossep
    # otarget: ossep
    def copyfile(abssrc, relsrc, otarget, exact):
        abstarget = util.canonpath(repo.root, cwd, otarget)
        reltarget = repo.pathto(abstarget, cwd)
        target = repo.wjoin(abstarget)
        src = repo.wjoin(abssrc)
        state = repo.dirstate[abstarget]

        # check for collisions
        prevsrc = targets.get(abstarget)
        if prevsrc is not None:
            ui.warn(_('%s: not overwriting - %s collides with %s\n') %
                    (reltarget, repo.pathto(abssrc, cwd),
                     repo.pathto(prevsrc, cwd)))
            return

        # check for overwrites
        exists = os.path.exists(target)
        if (not after and exists or after and state in 'mn'):
            if not opts['force']:
                ui.warn(_('%s: not overwriting - file exists\n') %
                        reltarget)
                return

        if after:
            if not exists:
                return
        elif not dryrun:
            try:
                if exists:
                    os.unlink(target)
                targetdir = os.path.dirname(target) or '.'
                if not os.path.isdir(targetdir):
                    os.makedirs(targetdir)
                util.copyfile(src, target)
            except IOError, inst:
                if inst.errno == errno.ENOENT:
                    ui.warn(_('%s: deleted in working copy\n') % relsrc)
                else:
                    ui.warn(_('%s: cannot copy - %s\n') %
                            (relsrc, inst.strerror))
                    return True # report a failure

        if ui.verbose or not exact:
            action = rename and "moving" or "copying"
            ui.status(_('%s %s to %s\n') % (action, relsrc, reltarget))

        targets[abstarget] = abssrc

        # fix up dirstate
        origsrc = repo.dirstate.copied(abssrc) or abssrc
        if abstarget == origsrc: # copying back a copy?
            if state not in 'mn' and not dryrun:
                repo.dirstate.normallookup(abstarget)
        else:
            if repo.dirstate[origsrc] == 'a':
                if not ui.quiet:
                    ui.warn(_("%s has not been committed yet, so no copy "
                              "data will be stored for %s.\n")
                            % (repo.pathto(origsrc, cwd), reltarget))
                if abstarget not in repo.dirstate and not dryrun:
                    repo.add([abstarget])
            elif not dryrun:
                repo.copy(origsrc, abstarget)

        if rename and not dryrun:
            repo.remove([abssrc], not after)

    # pat: ossep
    # dest ossep
    # srcs: list of (hgsep, hgsep, ossep, bool)
    # return: function that takes hgsep and returns ossep
    def targetpathfn(pat, dest, srcs):
        if os.path.isdir(pat):
            abspfx = util.canonpath(repo.root, cwd, pat)
            abspfx = util.localpath(abspfx)
            if destdirexists:
                striplen = len(os.path.split(abspfx)[0])
            else:
                striplen = len(abspfx)
            if striplen:
                striplen += len(os.sep)
            res = lambda p: os.path.join(dest, util.localpath(p)[striplen:])
        elif destdirexists:
            res = lambda p: os.path.join(dest,
                                         os.path.basename(util.localpath(p)))
        else:
            res = lambda p: dest
        return res

    # pat: ossep
    # dest ossep
    # srcs: list of (hgsep, hgsep, ossep, bool)
    # return: function that takes hgsep and returns ossep
    def targetpathafterfn(pat, dest, srcs):
        if util.patkind(pat, None)[0]:
            # a mercurial pattern
            res = lambda p: os.path.join(dest,
                                         os.path.basename(util.localpath(p)))
        else:
            abspfx = util.canonpath(repo.root, cwd, pat)
            if len(abspfx) < len(srcs[0][0]):
                # A directory. Either the target path contains the last
                # component of the source path or it does not.
                def evalpath(striplen):
                    score = 0
                    for s in srcs:
                        t = os.path.join(dest, util.localpath(s[0])[striplen:])
                        if os.path.exists(t):
                            score += 1
                    return score

                abspfx = util.localpath(abspfx)
                striplen = len(abspfx)
                if striplen:
                    striplen += len(os.sep)
                if os.path.isdir(os.path.join(dest, os.path.split(abspfx)[1])):
                    score = evalpath(striplen)
                    striplen1 = len(os.path.split(abspfx)[0])
                    if striplen1:
                        striplen1 += len(os.sep)
                    if evalpath(striplen1) > score:
                        striplen = striplen1
                res = lambda p: os.path.join(dest,
                                             util.localpath(p)[striplen:])
            else:
                # a file
                if destdirexists:
                    res = lambda p: os.path.join(dest,
                                        os.path.basename(util.localpath(p)))
                else:
                    res = lambda p: dest
        return res


    pats = util.expand_glob(pats)
    if not pats:
        raise util.Abort(_('no source or destination specified'))
    if len(pats) == 1:
        raise util.Abort(_('no destination specified'))
    dest = pats.pop()
    destdirexists = os.path.isdir(dest) and not os.path.islink(dest)
    if not destdirexists:
        if len(pats) > 1 or util.patkind(pats[0], None)[0]:
            raise util.Abort(_('with multiple sources, destination must be an '
                               'existing directory'))
        if util.endswithsep(dest):
            raise util.Abort(_('destination %s is not a directory') % dest)

    tfn = targetpathfn
    if after:
        tfn = targetpathafterfn
    copylist = []
    for pat in pats:
        srcs = walkpat(pat)
        if not srcs:
            continue
        copylist.append((tfn(pat, dest, srcs), srcs))
    if not copylist:
        raise util.Abort(_('no files to copy'))

    errors = 0
    for targetpath, srcs in copylist:
        for abssrc, relsrc, exact in srcs:
            if copyfile(abssrc, relsrc, targetpath(abssrc), exact):
                errors += 1

    if errors:
        ui.warn(_('(consider using --after)\n'))

    return errors

